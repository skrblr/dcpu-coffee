// Generated by CoffeeScript 1.3.3
(function() {
  var Assembler, Data, Instr, Instruction, LabelValue, LitValue, MemValue, Module, RawValue, RegValue, SpecialValue, dasm, decode;

  Module = {};

  decode = require('./dcpu-decode');

  dasm = require('./dcpu-disasm');

  Instr = decode.Instr;

  RegValue = (function() {

    function RegValue(asm, reg) {
      this.mAsm = asm;
      this.mReg = reg;
    }

    RegValue.prototype.emit = function(stream) {
      return [];
    };

    RegValue.prototype.encode = function() {
      return this.mReg;
    };

    return RegValue;

  })();

  MemValue = (function() {

    function MemValue(asm, reg, lit) {
      if (reg == null) {
        reg = void 0;
      }
      if (lit == null) {
        lit = void 0;
      }
      this.mAsm = asm;
      this.mReg = reg;
      this.mLit = lit;
      if ((this.mLit != null) && this.mLit > 0x1f) {
        this.mAsm.incPc();
      }
    }

    MemValue.prototype.emit = function(stream) {
      if (this.mLit != null) {
        return stream.push(this.mLit);
      }
    };

    MemValue.prototype.encode = function() {
      if ((this.mLit != null) && (this.mReg != null)) {
        return this.mReg + 0x10;
      } else if (this.mReg != null) {
        return this.mReg + 0x8;
      } else if (this.mLit != null) {
        return 0x1e;
      } else {
        return console.log("ERROR: MemValue with corrupted state.");
      }
    };

    return MemValue;

  })();

  LitValue = (function() {

    function LitValue(asm, lit) {
      this.mAsm = asm;
      this.mLit = lit;
      if (this.mLit > 0x1f) {
        this.mAsm.incPc();
      }
    }

    LitValue.prototype.emit = function(stream) {
      if (this.mLit > 0x1e) {
        return stream.push(this.mLit);
      }
    };

    LitValue.prototype.encode = function() {
      if (this.mLit === 0xffff) {
        return 0x20;
      } else if (this.mLit > 0x1f) {
        return 0x1f;
      } else {
        return this.mLit + 0x21;
      }
    };

    return LitValue;

  })();

  SpecialValue = (function() {

    function SpecialValue(asm, enc) {
      this.mEnc = enc;
    }

    SpecialValue.prototype.emit = function() {
      return void 0;
    };

    SpecialValue.prototype.encode = function() {
      return this.mEnc;
    };

    return SpecialValue;

  })();

  LabelValue = (function() {

    function LabelValue(asm, lbl) {
      this.mAsm = asm;
      this.mLbl = lbl;
      this.mAsm.incPc();
    }

    LabelValue.prototype.resolve = function() {
      var addr;
      addr = this.mAsm.lookup(this.mLbl);
      if (!(addr != null)) {
        console.log("Undefined label '" + this.mLbl + "'");
      }
      return addr;
    };

    LabelValue.prototype.emit = function(stream) {
      var addr;
      addr = this.resolve();
      if (!(addr != null)) {
        return false;
      }
      return stream.push(addr);
    };

    LabelValue.prototype.encode = function() {
      var addr;
      addr = this.resolve();
      if (!(addr != null)) {
        return false;
      }
      return 0x1f;
    };

    return LabelValue;

  })();

  RawValue = (function() {

    function RawValue(asm, raw) {
      this.mAsm = asm;
      this.mRaw = raw;
    }

    RawValue.prototype.emit = function() {
      return void 0;
    };

    RawValue.prototype.encode = function() {
      return this.mRaw;
    };

    return RawValue;

  })();

  Instruction = (function() {

    function Instruction(asm, opc, vals) {
      this.mAsm = asm;
      this.mLine = 0;
      this.mSize = 0;
      this.mOp = opc;
      this.mVals = vals;
    }

    Instruction.prototype.emit = function(stream) {
      var enc, instr, v, _i, _len, _ref, _results;
      enc = (function() {
        var _i, _len, _ref, _results;
        _ref = this.mVals;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          _results.push(v.encode());
        }
        return _results;
      }).call(this);
      instr = this.mOp | (enc[0] << 5) | (enc[1] << 10);
      stream.push(instr);
      _ref = this.mVals;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(v.emit(stream));
      }
      return _results;
    };

    return Instruction;

  })();

  Data = (function() {

    function Data(asm, dat) {
      this.mAsm = asm;
      this.mData = dat;
    }

    Data.prototype.emit = function(stream) {
      return stream.push(this.mData);
    };

    return Data;

  })();

  Assembler = (function() {

    function Assembler() {
      var op, _i, _j, _len, _len1, _ref, _ref1;
      this.mText = "";
      this.mLabels = {};
      this.mPc = 0;
      this.mInstrs = [];
      this.mOpcDict = {};
      _ref = Instr.BASIC_OPS;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        op = _ref[_i];
        if (op != null) {
          this.mOpcDict[op.id.toUpperCase()] = op;
        }
      }
      _ref1 = Instr.ADV_OPS;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        op = _ref1[_j];
        if (op != null) {
          this.mOpcDict[op.id.toUpperCase()] = op;
        }
      }
    }

    Assembler.prototype.label = function(name, addr) {
      return this.mLabels[name] = addr;
    };

    Assembler.prototype.lookup = function(name) {
      return this.mLabels[name];
    };

    Assembler.prototype.defined = function(name) {
      return lookup(name) != null;
    };

    Assembler.prototype.incPc = function() {
      return ++this.mPc;
    };

    Assembler.prototype.processValue = function(val) {
      var arr_regex, ilit_regex, ireg_regex, lit_regex, match, n, r, reg_regex, regid, success;
      val = val.trim();
      reg_regex = /^([a-zA-Z_]+)$/;
      ireg_regex = /^\[\s*([a-zA-Z]+|\d+)\s*\]$/;
      lit_regex = /^(0[xX][0-9a-fA-F]+|\d+)$/;
      ilit_regex = /^\[\s*(0[xX][0-9a-fA-F]+|\d+)\s*\]$/;
      arr_regex = /^\[\s*(0[xX][0-9a-fA-F]+|\d+)\s*\+\s*([A-Z]+)\s*\]$/;
      success = function(val) {
        return {
          result: "success",
          value: val
        };
      };
      if (match = val.match(reg_regex)) {
        switch (match[1]) {
          case "POP":
            return success(new SpecialValue(this, 0x18));
          case "PEEK":
            return success(new SpecialValue(this, 0x19));
          case "PUSH":
            return success(new SpecialValue(this, 0x1a));
          case "SP":
            return success(new SpecialValue(this, 0x1b));
          case "PC":
            return success(new SpecialValue(this, 0x1c));
          case "O":
            return success(new SpecialValue(this, 0x1d));
          default:
            regid = dasm.Disasm.REG_DISASM.indexOf(match[1]);
            if (regid === -1) {
              return success(new LabelValue(this, match[1]));
            } else {
              return success(new RegValue(this, regid));
            }
        }
      } else if (match = val.match(ireg_regex)) {
        regid = dasm.Disasm.REG_DISASM.indexOf(match[1]);
        return success(new MemValue(this, regid, void 0));
      } else if (match = val.match(lit_regex)) {
        return success(new LitValue(this, parseInt(match[1])));
      } else if (match = val.match(ilit_regex)) {
        n = parseInt(match[1]);
        return success(new MemValue(this, void 0, n));
      } else if (match = val.match(arr_regex)) {
        n = parseInt(match[1]);
        r = dasm.Disasm.REG_DISASM.indexOf(match[2]);
        return success(new MemValue(this, r, n));
      } else {
        return r = {
          result: "fail",
          message: "Unmatched value " + val
        };
      }
    };

    Assembler.prototype.processLine = function(line) {
      var adv_regex, basic_regex, enc, match, n, opc, r, toks, valA, valB, _ref, _ref1;
      line = line.trim().toUpperCase();
      if (line === "") {
        return r = {
          result: "success"
        };
      }
      basic_regex = /(\w+)\s+([^,]+)\s*,\s*([^,]+)/;
      adv_regex = /(\w+)\s+([^,]+)/;
      toks = line.match(/[^ \t]+/g);
      if (line[0] === ":") {
        this.label(toks[0].slice(1), this.mPc);
        return this.processLine(toks.slice(1).join(" "));
      } else if (line[0] === ";") {
        return r = {
          result: "success"
        };
      } else if (toks[0] === "DAT") {
        n = parseInt(toks[1]);
        this.mInstrs.push(new Data(this, n));
        return r = {
          result: "success"
        };
      } else if (match = line.match(basic_regex)) {
        _ref = match.slice(1, 4), opc = _ref[0], valA = _ref[1], valB = _ref[2];
        if (!(this.mOpcDict[opc] != null)) {
          return r = {
            result: "fail",
            message: "Unknown Opcode: " + opc
          };
        }
        enc = this.mOpcDict[opc].op;
        this.incPc();
        valA = this.processValue(valA);
        if (valA.result !== "success") {
          return valA;
        }
        valB = this.processValue(valB);
        if (valB.result !== "success") {
          return valB;
        }
        this.mInstrs.push(new Instruction(this, enc, [valA.value, valB.value]));
        return r = {
          result: "success"
        };
      } else if (match = line.match(adv_regex)) {
        _ref1 = match.slice(1, 3), opc = _ref1[0], valA = _ref1[1];
        if (!(this.mOpcDict[opc] != null)) {
          return r = {
            result: "fail",
            message: "Unknown Opcode: " + opc
          };
        }
        enc = this.mOpcDict[opc].op;
        this.incPc();
        valB = this.processValue(valA);
        if (valB.result !== "success") {
          return valB;
        }
        valA = new RawValue(this, enc);
        this.mInstrs.push(new Instruction(this, 0, [valA, valB.value]));
        return r = {
          result: "success"
        };
      } else {
        return r = {
          result: "fail",
          source: line,
          message: "Syntax Error"
        };
      }
    };

    Assembler.prototype.emit = function(stream) {
      var i, _i, _len, _ref, _results;
      _ref = this.mInstrs;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        _results.push(i.emit(stream));
      }
      return _results;
    };

    Assembler.prototype.assemble = function(text) {
      var index, l, lines, prog, r, state, _i, _len;
      prog = [];
      lines = text.split("\n");
      index = 1;
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        l = lines[_i];
        state = this.processLine(l);
        if (state.result !== "success") {
          state.line = index;
          return state;
        }
        index++;
      }
      this.emit(prog);
      return r = {
        result: "success",
        code: prog
      };
    };

    return Assembler;

  })();

  exports.Assembler = Assembler;

}).call(this);
